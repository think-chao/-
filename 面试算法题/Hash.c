/**************************************************
 * 对于索引查找算法来说，记录保存的位置和关键字之间不存在对应的关系
 * 在查找数据的时候需要经过不断的与关键字进行对比
 * 
 * 散列函数就是将关键字与记录保存的位置之间形成一种函数对应关系，称为散列函数，这种方式建立的表叫做散列表
 * 
 * 散列表的基本思想：
 * 以线性表中每个元素的关键字key作为自变量，通过一定的函数计算出函数的值，将这个值作为数组的下标
 * 然后将元素存入到对应的数组元素中
 * ******************************************************/

/*************************************************************************
 * 构造散列函数的几种方法：
 * （1） 直接定址法
 *       key+C
 *  (2) 除法取余法
 *       key%n  n是奇数，最好是素数
 * （3） 平方取中法
 *      key平方之后取中间的几位，这种方法适合关键字每一位都不够分散
 * ************************************************************************/


/**********************************************************************
 * 冲突解决方法
 * 虽然构造散列函数的时候就尽可能的避免冲突，但是冲突是在所难免的
 * （1） 开放地址法
 *      开放地址就是散列表中未曾使用的数组元素的地址，加入发生冲突，就从发生冲突的那个元素开始，按照一定的次序，从散列表中查出一个空闲的数组元素
 *      1. 线性探测法
 *          从发生冲突的单元开始，向后探测，直到找到开放地址为止
 *      2. 双散列函数探测法
 *          h为主散列函数，h1为次散列函数，当有h计算得到的地址被占用了的时候，就向后移动h1（key）个单元再次探测开放单元
 * （2） 链接法
 *      在散列表中的每个存储单元中增一个指针域，把散列地址相同的元素链接起来
 * ************************************************************************/


#include <stdio.h>
#define HASH_LEN 13
#define TABLE_LEN 8
int data[TABLE_LEN]={69,65,90,37,92,6,28,54}; //原始数据 
int hash[HASH_LEN]={0};//哈希表，初始化为0 

void Insert(int hash[],int m,int data){
    int i;
    i=data % 13;
    while(hash[i]){
        i=(++i) % m;
    }
    hash[i]=data;
}

void CreateHash(int hash[],int m,int data[],int n)
{
    int i;
    for(i=0;i<n;i++) //循环将原始数据保存到哈希表中 
        InsertHash(hash,m,data[i]); 
}

int HashSearch(int hash[],int m,int key)
{
    int i;
    i=key % 13;//计算哈希地址 
    while(hash[i] && hash[i]!=key) //判断是否冲突 
        i=(++i) % m; //线性探测法解决冲突
    if(hash[i]==0) //查找到开放单元，表示查找失败 
        return -1;//返回失败值 
    else//查找成功 
        return i;//返回对应元素的下标 
}


